#+TITLE: .emacs.d
#+AUTHOR: Andriy Kmit'
#+STARTUP: show2levels
#+PROPERTY: header-args    :tangle init.el
#+PROPERTY: header-args+   :lexical t

This is a personal configuration of [[https://www.gnu.org/software/emacs/][GNU Emacs]].

Currently, this is in WIP state, and my daily driver is still a heavily
customized Spacemacs [[https://github.com/madand/dotemacs][setup]]; which gives me inspiration for what third party
packages might be of use and how to build (semi-)mnemonic key bindings.
 
* Early Config

This section contains stuff that must be at the very top of the init file.

** Preamble

The heading part of the tangled ~init.el~ file.

#+begin_src emacs-lisp
;;; init.el --- The Emacs Initialization File        -*- lexical-binding: t; -*-

;; Copyright (C) 2021 Andriy Kmit'

;; Author: Andriy Kmit' <dev@madand.net>
;; URL: https://github.com/madand/.emacs.d

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This file was tangled (generated) from the file README.org. Thus, you SHOULD
;; NOT modify this file directly. Instead, edit and re-tangle the README.org.

;;; Code:
#+end_src

** Custom Settings in a Separate File

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

** Native Compilation

[[info:elisp#Native Compilation][Native Compilation]]

Allow native compilation to utilize all available cores.

#+begin_src emacs-lisp
(setq native-comp-async-jobs-number (num-processors))
#+end_src

* Package Management

The packages that streamline the installation and configuration of packages üì¶

** straight.el

[[https://github.com/raxod502/straight.el]]

#+begin_src emacs-lisp
  (setq straight-vc-git-auto-fast-forward nil
        straight-use-package-by-default t
        straight-check-for-modifications '(check-on-save find-when-checking))

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5)
        (revision "4a473e51dea1ff5eeffee2eb193c3bade628b35e"))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           (format "https://raw.githubusercontent.com/raxod502/straight.el/%s/install.el" revision)
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** use-package

[[https://github.com/jwiegley/use-package]]

#+begin_src emacs-lisp
(straight-use-package 'use-package)
(require 'use-package)

(use-package use-package
  :bind (:map help-map
         ("B" . describe-personal-keybindings)))
#+end_src

From this point on, we can use the ~use-package~ macro for package configuration.

*** Gathering Statistics

For gathering package statistics tangle the following block and ~M-x
use-package-report~.

#+begin_src emacs-lisp
(setq use-package-compute-statistics t)
#+end_src

** no-littering

[[https://github.com/emacscollective/no-littering]]

This package must be loaded as early as possible.

#+begin_src emacs-lisp
(use-package no-littering)
#+end_src

** delight

[[https://www.emacswiki.org/emacs/DelightedModes]]

Delight enables you to easily customise how major and minor modes appear in the
Mode Line.

#+begin_src emacs-lisp
(use-package delight)
#+end_src

* Display

** Fonts

*** Font Family

Use [[https://github.com/be5invis/iosevka][Iosevka]] as the monospace font, and [[https://fonts.google.com/noto/specimen/Noto+Serif][Noto Serif]] as the proportional one.

Note that with Emacs 28 or newer and with [[https://github.com/googlefonts/noto-emoji][Noto Emoji]] font installed, you get the
full support for displaying emojis. No configuration needed!

#+begin_src emacs-lisp
(defvar my-font-mono (font-spec :family "Iosevka SS09" :size 16))
;; (defvar my-font-mono-serif (font-spec :family "Iosevka Slab"))
(defvar my-font-proportional (font-spec :family "Noto Serif" :size 20))

(set-frame-font my-font-mono t t)

(set-face-font  'default            my-font-mono)
(set-face-font  'fixed-pitch        my-font-mono)
(set-face-font  'fixed-pitch-serif  my-font-mono)
(set-face-font  'variable-pitch     my-font-proportional)
#+end_src

*** Font Size

#+begin_src emacs-lisp
(defvar my-font-sizes '(:laptop (16 20) :monitor (21 26)))

(defun my-set-faces-font-size (sizes)
  (pcase-let ((`(,fixed-font-size ,variable-font-size) sizes))
    (set-face-font 'variable-pitch (font-spec :size variable-font-size))
    (dolist (face '(default fixed-pitch fixed-pitch-serif))
      (set-face-font face (font-spec :size fixed-font-size) (window-frame)))))

(defun my-set-font-size-laptop ()
  (interactive)
  (my-set-faces-font-size (plist-get my-font-sizes :laptop)))

(defun my-set-font-size-monitor ()
  (interactive)
  (my-set-faces-font-size (plist-get my-font-sizes :monitor)))

(defun my-set-font-size-monitor-function (&rest _)
  (cond
   ((> (cl-third (frame-monitor-geometry)) 1366)
    (my-set-font-size-monitor))
   (t (my-set-font-size-laptop))))

(add-hook 'window-size-change-functions #'my-set-font-size-monitor-function)
(advice-add 'load-theme :after #'my-set-font-size-monitor-function)
#+end_src

Ensure that mode line will be displayed with the fixed font size, not tied to
the font size of the ~default~ face.

#+begin_src emacs-lisp
(defface my-mode-line-font
  nil
  "This face ensures the font size for the mode line."
  :group 'mode-line-faces)

(set-face-font 'my-mode-line-font my-font-mono)

(defun my-set-mode-line-font-face (&rest _)
  (set-face-attribute 'mode-line nil :inherit 'my-mode-line-font)
  (set-face-attribute 'mode-line-inactive nil :inherit 'my-mode-line-font))

(advice-add 'load-theme :after #'my-set-mode-line-font-face)
#+end_src

*** Miscellaneous Font Configuration

Allow modes to display bold and/or italic text. Particularly, this makes
websites rendered in [[https://www.gnu.org/software/emacs/manual/html_mono/eww.html][EWW]] mode look much better:

#+begin_src emacs-lisp
(defun my-allow-bold-italic-variable-pitch (&rest _)
  (set-face-attribute 'variable-pitch nil :slant 'unspecified :weight 'unspecified))

(advice-add 'load-theme :after #'my-allow-bold-italic-variable-pitch)
#+end_src

** Themes: Modus Themes

Use the theme ~modus-operandi~.

#+begin_src emacs-lisp
(load-theme 'modus-operandi t)
#+end_src

** text-scale+

[[https://github.com/madand/text-scale-plus.el]]

Improve ~text-scale-mode~ with multi-face support.

#+begin_src emacs-lisp
(use-package text-scale+
  :straight '(text-scale+ :host github :repo "madand/text-scale-plus.el"))
#+end_src

** form-feed

[[https://depp.brause.cc/form-feed/]]

Display ^L glyphs as horizontal lines.

#+begin_src emacs-lisp
(use-package form-feed
  :straight '(form-feed :host nil :repo "https://depp.brause.cc/form-feed.git")
  :delight
  :init (global-form-feed-mode))
#+end_src

** display-fill-column-indicator

[[info:emacs#Displaying Boundaries][emacs#Displaying Boundaries]]

#+begin_src emacs-lisp
(defvar my-toggles-map (make-sparse-keymap))
(global-set-key (kbd "C-<f1>") my-toggles-map)

(use-package display-fill-column-indicator
  :straight nil				; Built-in package
  :bind ( :map my-toggles-map
	  ("f" . display-fill-column-indicator-mode)))
#+end_src

* Fundamental External Packages

Third-party packages that are fundamental for my setup. They might improve your
Emacs workflow in major ways. Moreover, they synergize with each other!

#+begin_src emacs-lisp
(defvar my-quick-select-keys '(?n ?o ?e ?t ?a ?i ?r ?h)
  "Keys for performing quick selections/jumps with tools like Avy.")
#+end_src

** Avy

- [[https://github.com/abo-abo/avy]]
- [[https://karthinks.com/software/avy-can-do-anything/]]

avy is a GNU Emacs package for jumping to visible text using a
char-based decision tree. It allows one to jump to any visible text with just
3-5 key strokes (even between windows and frames).

#+begin_src emacs-lisp
(defvar xref-prompt-for-identifier)
(defun my-avy-action-find-definitions (pt)
  (goto-char pt)
  (let ((xref-prompt-for-identifier nil))
    (call-interactively #'xref-find-definitions)))

(defvar my-avy-dispatch-alist
  '((?k . avy-action-kill-move)
    (?K . avy-action-kill-stay)
    (?m . avy-action-teleport)
    (?v . avy-action-mark)
    (?c . avy-action-copy)
    (?i . avy-action-ispell)
    (?y . avy-action-yank)
    (?Y . avy-action-yank-line)
    (?z . avy-action-zap-to-char)
    ;; Custom actions
    (?d . my-avy-action-find-definitions)
    ;; (?g . madand//avy-action-translate-stay)
    )
  "Override value of `avy-dispatch-alist' to prevent conflicts when
`avy-keys' is set to Keymacs home row keys (raenotih).
See also `my-quick-select-keys'.")
#+end_src

#+begin_src emacs-lisp
(use-package avy
  :custom
  (avy-keys my-quick-select-keys)
  (avy-dispatch-alist my-avy-dispatch-alist)
  (avy-timeout-seconds 0.4)
  (avy-background t)
  (avy-single-candidate-jump nil)
  :bind (("M-o" . avy-goto-char-timer)
         ("C-M-," . avy-goto-line)))
#+end_src

*** Avy Embark Integration

#+begin_src emacs-lisp
(defun my-avy-action-embark (pt)
  (unwind-protect
      (save-excursion
        (goto-char pt)
        (embark-act))
    (select-window
     (cdr (ring-ref avy-ring 0))))
  t)

(with-eval-after-load 'avy
  (setf (alist-get ?. avy-dispatch-alist) #'my-avy-action-embark))
#+end_src

** link-hint

[[https://github.com/noctuid/link-hint.el]]

Use Avy to open, copy, or take a user-defined action on ‚Äúlinks‚Äù.

#+begin_src emacs-lisp
(use-package link-hint
  :bind (("C-;" . link-hint-open-link)
	 :map Info-mode-map (";" . link-hint-open-link)
         ;; Modes that derive from `special-mode': `eww-mode', `help-mode',
	 ;; `magit-mode'
	 :map special-mode-map (";" . link-hint-open-link))
  :init
  (with-eval-after-load 'cus-edit
    (define-key custom-mode-map (kbd ";") #'link-hint-open-link))
  (with-eval-after-load 'view
    (define-key view-mode-map (kbd ";") #'link-hint-open-link)))
#+end_src

Fix ~link-hint~ scrolling window up when point is in the last visible line of a
Customize buffer:

#+begin_src emacs-lisp
(defun my-with-inhibit-resize-mini-widows (function &rest arguments)
  "Call FUNCTION with ARGUMENTS, with `resize-mini-windows' bound to nil."
  (let ((resize-mini-windows nil))
    (apply function arguments)))

(advice-add 'link-hint-open-link :around #'my-with-inhibit-resize-mini-widows)
;; (advice-remove 'link-hint-open-link  #'my-with-inhibit-resize-mini-widows)
#+end_src

** Embark

[[https://github.com/oantolin/embark]]

#+begin_src emacs-lisp
(use-package embark
  :bind (("C-." . embark-act)
	 ("M-." . embark-dwim)))
#+end_src

** Marginalia

[[https://github.com/minad/marginalia]]

#+begin_src emacs-lisp
(use-package marginalia
  :bind
  (("M-A" . marginalia-cycle))
  :init
  (marginalia-mode))
#+end_src

** Orderless

[[https://github.com/oantolin/orderless]]

#+begin_src emacs-lisp
(use-package orderless
  :custom
  (completion-styles '(orderless))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Vertico

[[https://github.com/minad/vertico]]

#+begin_src emacs-lisp
(use-package vertico
  :init
  (vertico-mode)
  (setq vertico-scroll-margin 1)
  (setq vertico-count 16)
  (setq vertico-cycle t))
#+end_src

** Consult

#+begin_src emacs-lisp
(use-package consult)
#+end_src

* Minibuffer

[[info:emacs#Minibuffer][emacs#Minibuffer]]

Allow recursive minibuffers:

#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
(minibuffer-depth-indicate-mode 1)
#+end_src

Make default argument be displayed as ~[DEFAULT-ARG]~ instead of
~(default DEFAULT-ARG)~, saving some screen space:

#+begin_src emacs-lisp
(setq minibuffer-eldef-shorten-default t)
#+end_src

** Less Garbage Collections in Minibuffer                      :experimental:

Tangle this only if you want to exeriment with the increased GC thresholds while
the minibuffer is open.

May be worth it if you like to spawn numerous short living Emacs instances.

On the other hand, most likely not worth it with a single long living Emacs
server process. Because, the heap size will grow faster, thus making every
subsequent garbage collection take more time.

#+begin_src emacs-lisp :tangle no
(defvar my-gc-cons-threshold-minibuffer (* 50 (expt 1024 2)))
(defvar my--gc-cons-threshold-original)

(defun my-gc-minibuffer-setup-function ()
  "Increase GC thresholds while the minibuffer is active."
  (setq my--gc-cons-threshold-original gc-cons-threshold
	gc-cons-threshold my-gc-cons-threshold-minibuffer))

(defun my-gc-minibuffer-exit-function ()
  "Reset GC thresholds after exiting the minibuffer."
  (setq gc-cons-threshold my--gc-cons-threshold-original))

(add-hook 'minibuffer-setup-hook #'my-gc-minibuffer-setup-function)
(add-hook 'minibuffer-exit-hook #'my-gc-minibuffer-exit-function)
#+end_src

* Files

** find file (or url) at point

Replace ~find-file~ and friends with smarter versions.

#+begin_src emacs-lisp
(ffap-bindings)
#+end_src

When a file is opened read-only, enable ~view-mode~.

#+begin_src emacs-lisp
(defun my-turn-on-view-mode (&rest _)
  (view-mode 1))

(advice-add 'ffap-read-only :after #'my-turn-on-view-mode)
(advice-add 'ffap-read-only-other-window :after #'my-turn-on-view-mode)
#+end_src

* Frames

Rebind ~C-x 5 c~ because its original command, ~clone-frame~, may crash Emacs.

#+begin_src emacs-lisp
(define-key ctl-x-5-map "c" #'make-frame-command)
#+end_src

* Misc

#+begin_src emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

Kitchen sink for the time being.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") #'ibuffer)
(global-set-key (kbd "C-x k") #'kill-this-buffer)
(global-set-key (kbd "C-z") #'set-mark-command)

(global-set-key (kbd "C-c v") #'view-mode)

(global-set-key (kbd "M-c") #'capitalize-dwim)
(global-set-key (kbd "M-l") #'downcase-dwim)
(global-set-key (kbd "M-u") #'upcase-dwim)

(define-key help-map "-" #'describe-syntax)
(define-key help-map "S" nil)
(define-key help-map "s" #'info-lookup-symbol)

(define-key emacs-lisp-mode-map (kbd "<f5>") #'eval-defun)

(setq set-mark-command-repeat-pop t)

(setq read-extended-command-predicate #'command-completion-default-include-p)

(setq tab-always-indent 'complete)
;; https://codeberg.org/joostkremers/visual-fill-column/src/branch/main/visual-fill-column.el

;; Read buffer for external processes.
(setq read-process-output-max (* 256 1024))
(setq source-directory (expand-file-name "~/git/emacs-git/"))

(setq-default fill-column 80)

(setq show-paren-when-point-inside-paren t)
(electric-pair-mode)
(repeat-mode)

(use-package mwim
  :bind (("C-a" . mwim-beginning)
	 ("C-e" . mwim-end)))
#+end_src

** Startup

#+begin_src emacs-lisp
(use-package startup
  :straight nil                         ; Built-in package
  :no-require t
  :custom
  (initial-buffer-choice (expand-file-name "README.org" user-emacs-directory))
  (inhibit-default-init t)
  (inhibit-startup-screen t)
  (inhibit-startup-echo-area-message t)
  (inhibit-startup-message t)
  (initial-scratch-message nil))
#+end_src

** Incremental Search (isearch)

~-~ key can be used without using ~Shift~.

#+begin_src emacs-lisp
(define-key search-map "-" #'isearch-forward-symbol)
#+end_src

** History

** Xref

[[info:emacs#Xref][emacs#Xref]]

Make xref use rg for faster searches:

#+begin_src emacs-lisp
(use-package xref
  :straight nil
  :custom
  (xref-search-program 'ripgrep))
#+end_src

Make the found definition be displayed at the top of the window:

#+begin_src emacs-lisp
(defun my-recenter-top-1 ()
  "Recenter point to 1 line below the top of the window."
  (recenter 1))

(remove-hook 'xref-after-update-hook 'recenter)
(add-hook 'xref-after-update-hook #'my-recenter-top-1)
#+end_src

** Auto Save

[[info:emacs#Auto Save Files][emacs#Auto Save Files]]

Auto-save a file after typing 100 characters.

#+begin_src emacs-lisp
(setq auto-save-interval 100)
#+end_src

Do not bother us with the message ~Auto-saving...done~.

#+begin_src emacs-lisp
(setq auto-save-no-message t)
#+end_src

Store auto save files under the ~var/auto-save/~ directory, not to litter the
working drectories.

#+begin_src emacs-lisp
(let* ((hash-algo 'sha256)
       (base-dir (no-littering-expand-var-file-name "auto-save/"))
       (remote-files-dir (file-name-concat base-dir "remote/"))
       (local-files-dir (file-name-concat base-dir "local/")))
  (setq auto-save-file-name-transforms
	`(("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" ,remote-files-dir ,hash-algo)
	  (".*" ,local-files-dir ,hash-algo)))
  (dolist (dir (list remote-files-dir local-files-dir))
    (unless (file-directory-p dir)
      (make-directory dir))))
#+end_src
 
** Help

#+begin_src emacs-lisp
(use-package help
  :straight nil
  :custom
  (help-window-select t)
  :bind
  (("C-h C-l" . find-library)))
#+end_src

** rainbow-mode

#+begin_src emacs-lisp
(use-package rainbow-mode
  :bind
  ( :map my-toggles-map
    ("r" . rainbow-mode)))
#+end_src

* Version Control
** Magit

[[https://magit.vc/]]

#+begin_src emacs-lisp
(use-package magit
  :defer t
  :init
  (setq magit-define-global-key-bindings t))
#+end_src

** vc

Don't annoy us with ~Symbolic link to Git-controlled source file; follow link?~.

#+begin_src emacs-lisp
(setq vc-follow-symlinks t)
#+end_src

* International

** Language Environments

[[info:emacs#Language Environments][Language Environments]]

#+begin_src emacs-lisp
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
#+end_src

* Narrowing

[[info:emacs#Narrowing][Narrowing]]

#+begin_src emacs-lisp
(global-set-key (kbd "<f9>") #'narrow-to-defun)
(global-set-key (kbd "<f10>") #'narrow-to-region)
(with-eval-after-load 'org
  (global-set-key (kbd "<f11>") #'org-narrow-to-subtree))
(global-set-key (kbd "<f12>") #'widen)
#+end_src

* Org Mode

[[https://orgmode.org/]]
[[info:org#Top][Org Info Manual]]

#+begin_src emacs-lisp
(use-package org
  :custom
  (org-edit-src-content-indentation 0)
  :bind (("C-c l" . org-store-link)
         ("C-c c" . org-capture)
         ("C-c a" . org-agenda)
         :map org-mode-map
         ("<f2>" . org-edit-special)
	 ("C-c C-j" . consult-org-heading)
         :map org-src-mode-map
         ("<f2>" . org-edit-src-exit)))
#+end_src

** Emacs Lisp in Org

Some conveniences for working with Elisp code blocks.

#+begin_src emacs-lisp
(defun my-org-insert-elisp-block ()
  "Insert Emacs Lisp code block."
  (interactive)
  (open-line 2)
  (forward-line)
  (org-insert-structure-template "src")
  (insert "emacs-lisp\n"))

(with-eval-after-load 'org
 (define-key org-mode-map (kbd "<f1>") #'my-org-insert-elisp-block))
#+end_src

#+begin_src emacs-lisp
(defun my-org-eval-defun ()
  "`eval-defun' that works in Org buffers."
  (interactive)
  (org-edit-src-code)
  (if (eq 'emacs-lisp-mode major-mode)
      (progn
        (eval-defun nil)
        (org-edit-src-exit))
    (org-edit-src-abort)
    (error "Not implemented for non-Elisp code blocks")))

(with-eval-after-load 'org
  (define-key org-mode-map (kbd "<f5>") #'my-org-eval-defun))
#+end_src

* Autotyping

[[info:autotype#Top][Autotype]]

** Abbrev Mode

#+begin_src emacs-lisp
(dolist (hook '(text-mode-hook prog-mode-hook))
  (add-hook hook #'abbrev-mode))
#+end_src

** Hippie Expand

[[info:autotype#Hippie Expand][Hippie Expand]]

#+begin_src emacs-lisp
(use-package hippie-exp
  :straight nil                         ; Built-in package
  :custom
  (hippie-expand-try-functions-list '(try-complete-file-name-partially
                                      try-complete-file-name
                                      try-expand-all-abbrevs
                                      try-expand-list
                                      try-expand-line
                                      try-expand-dabbrev
                                      try-expand-dabbrev-all-buffers
                                      try-expand-dabbrev-from-kill
                                      try-complete-lisp-symbol-partially
                                      try-complete-lisp-symbol))
  :bind (("M-/" . hippie-expand)))
#+end_src

* Lisp

Stuff for improving the experience when working with Lisp code.

** lisp-extra-font-lock

[[https://github.com/Lindydancer/lisp-extra-font-lock]]

This package adds highlighting for a bunch of additinal things. The best one, in
my opinion, is the highlighting of dynamically scoped variables (~defvar~) in
~let~-expressions.

#+begin_src emacs-lisp
(use-package lisp-extra-font-lock
  :custom
  (lisp-extra-font-lock-quoted-face nil)
  (lisp-extra-font-lock-quoted-function-face nil)
  (lisp-extra-font-lock-backquote-face nil)
  :init
  (lisp-extra-font-lock-global-mode))
#+end_src

** paredit

#+begin_src emacs-lisp
(use-package paredit
  :hook ((emacs-lisp-mode lisp-mode) . enable-paredit-mode))
#+end_src

** Elisp: indentation for `cl-flet' and friends

[[https://emacs.stackexchange.com/a/39177]]

#+begin_src emacs-lisp
(defvar my--elisp-flet-style-macros ()
  "List of elisp forms that should be indented like `flet'.")

(defun my-elisp-flet-indent-function (indent-point state)
  "Handle `flet'-like lists, otherwise call `lisp-indent-function'."
  (cond
   ((ignore-errors
      (save-excursion
        (backward-up-list 3)
        (down-list)
        (when (memq (intern (thing-at-point 'symbol))
                    my--elisp-flet-style-macros)
          (forward-sexp 2)
          (>= (point) indent-point))))
    (lisp-indent-defform state indent-point))
   (t (lisp-indent-function indent-point state))))

(defun my-elisp-setup-flet-indent ()
  "Setup proper indentation for `cl-flet' and similar forms in elisp."
  (setq my--elisp-flet-style-macros
        (let ((macros '(flet flet* values macrolet labels)))
          (append macros (mapcar (lambda (sym)
                                   (intern (format "cl-%s" (symbol-name sym))))
                                 macros))))
  (dolist (macro my--elisp-flet-style-macros)
    (put macro 'lisp-indent-function 'defun))
  (setq lisp-indent-function #'my-elisp-flet-indent-function))

(with-eval-after-load 'elisp-mode
    (my-elisp-setup-flet-indent))
#+end_src

** Profiler

#+begin_src emacs-lisp
(use-package profiler
  :straight nil
  :bind  ( :map my-toggles-map
	   ("p p" . profiler-start)
	   ("p r" . profiler-report)
	   ("p o" . profiler-reset)
	   ("p k" . profiler-stop)))
#+end_src

* Programming

** Web Mode

#+begin_src emacs-lisp
(use-package web-mode)
#+end_src

* License

GNU GPLv3.

* Epilogue

#+begin_src emacs-lisp
(defun my-compile-init-file ()
  "Byte and native (re)compile the Emacs init file (init.el)."
  (let ((init-file (expand-file-name "init.el" user-emacs-directory)))
    (byte-recompile-file init-file nil 0)
    (native-compile init-file)))
#+end_src

File-local variables defined here make Emacs (re)tangle and then (re)compile the
init file (~init.el~), whenever this file is saved.

#+begin_example
Local Variables:
eval: (add-hook 'after-save-hook #'org-babel-tangle 90 t)
eval: (add-hook 'after-save-hook #'my-compile-init-file 91 t)
fill-column: 80
indent-tabs-mode: nil
End:
#+end_example
